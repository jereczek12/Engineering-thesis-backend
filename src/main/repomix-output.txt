This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-14T16:49:30.158Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
java/com/jereczek/checkers/CheckersLearningSimulatorApplication.java
java/com/jereczek/checkers/config/WebsocketConfiguration.java
java/com/jereczek/checkers/controller/dto/ConnectRequestDTO.java
java/com/jereczek/checkers/controller/dto/GameHistoryDto.java
java/com/jereczek/checkers/controller/dto/GamePlayDTO.java
java/com/jereczek/checkers/controller/dto/GameStartDTO.java
java/com/jereczek/checkers/controller/dto/MoveDTO.java
java/com/jereczek/checkers/controller/dto/PlayerDTO.java
java/com/jereczek/checkers/controller/GameController.java
java/com/jereczek/checkers/controller/GameControllerExceptionHandler.java
java/com/jereczek/checkers/controller/GameHistoryController.java
java/com/jereczek/checkers/controller/RegisterController.java
java/com/jereczek/checkers/enums/GameStatus.java
java/com/jereczek/checkers/enums/PieceTypes.java
java/com/jereczek/checkers/enums/PlayerTypes.java
java/com/jereczek/checkers/exception/connection/AllPlayersConnectedException.java
java/com/jereczek/checkers/exception/connection/GameConnectionError.java
java/com/jereczek/checkers/exception/connection/GameFinishedException.java
java/com/jereczek/checkers/exception/connection/GameNotFoundException.java
java/com/jereczek/checkers/exception/IllegalMoveException.java
java/com/jereczek/checkers/exception/IllegalPlayerException.java
java/com/jereczek/checkers/game/ai/cache/BoardStateCacheService.java
java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheConfig.java
java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheEntry.java
java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheKey.java
java/com/jereczek/checkers/game/ai/evaluation/BoardEvaluator.java
java/com/jereczek/checkers/game/ai/evaluation/EvaluationConstants.java
java/com/jereczek/checkers/game/ai/evaluation/PositionsConstants.java
java/com/jereczek/checkers/game/ai/MiniMax.java
java/com/jereczek/checkers/game/ai/MiniMaxNode.java
java/com/jereczek/checkers/game/ai/movegenerator/MoveGenerator.java
java/com/jereczek/checkers/game/ai/MoveValidator.java
java/com/jereczek/checkers/game/CheckersGameLogic.java
java/com/jereczek/checkers/game/GameStateUtils.java
java/com/jereczek/checkers/game/KingMoveValidator.java
java/com/jereczek/checkers/game/LongestCaptureCalculator.java
java/com/jereczek/checkers/game/model/board/BoardMapper.java
java/com/jereczek/checkers/game/model/board/BoardState.java
java/com/jereczek/checkers/game/model/board/BoardUtils.java
java/com/jereczek/checkers/game/model/board/constants/BoardConstants.java
java/com/jereczek/checkers/game/model/board/Coordinates.java
java/com/jereczek/checkers/game/Move.java
java/com/jereczek/checkers/model/BoardEntity.java
java/com/jereczek/checkers/model/GameData.java
java/com/jereczek/checkers/model/GameEntity.java
java/com/jereczek/checkers/model/MovesListConverter.java
java/com/jereczek/checkers/model/players/Player.java
java/com/jereczek/checkers/model/players/PlayerCPU.java
java/com/jereczek/checkers/model/players/PlayerHuman.java
java/com/jereczek/checkers/movehelper/TipGenerator.java
java/com/jereczek/checkers/movehelper/TipModel.java
java/com/jereczek/checkers/movehelper/TipsAttributeConverter.java
java/com/jereczek/checkers/piece/Piece.java
java/com/jereczek/checkers/piece/PiecesNotationMapper.java
java/com/jereczek/checkers/repositories/IBoardStateRepo.java
java/com/jereczek/checkers/repositories/IGameDataRepo.java
java/com/jereczek/checkers/repositories/IGameRepo.java
java/com/jereczek/checkers/repositories/IPlayerRepo.java
java/com/jereczek/checkers/security/config/PasswordEncoderConfig.java
java/com/jereczek/checkers/security/config/WebSecurityConfig.java
java/com/jereczek/checkers/security/PlayerAuthenticationSuccessHandler.java
java/com/jereczek/checkers/security/UserDetailsServiceImpl.java
java/com/jereczek/checkers/service/CpuMovesAsyncConfig.java
java/com/jereczek/checkers/service/GameService.java
java/com/jereczek/checkers/service/PlayerService.java
resources/application-dev.yml
resources/application-prod.yml
resources/application.yml
resources/data.sql
resources/schema-update.sql

================================================================
Repository Files
================================================================

================
File: java/com/jereczek/checkers/CheckersLearningSimulatorApplication.java
================
package com.jereczek.checkers;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.web.bind.annotation.CrossOrigin;

@SpringBootApplication
@CrossOrigin
@EnableAsync
public class CheckersLearningSimulatorApplication {

    public static void main(String[] args) {
        SpringApplication.run(CheckersLearningSimulatorApplication.class, args);
    }

}

================
File: java/com/jereczek/checkers/config/WebsocketConfiguration.java
================
package com.jereczek.checkers.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebsocketConfiguration implements WebSocketMessageBrokerConfigurer {
    public static final String GAME_PROGRESS_TOPIC = "/topic/game-progress/";

    public static final String GAME_TIPS_TOPIC = "/topic/game-tips/";

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/gameplay")
                .setAllowedOrigins("http://localhost:4200")
                .withSockJS();

    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app").enableSimpleBroker("/topic");
    }
}

================
File: java/com/jereczek/checkers/controller/dto/ConnectRequestDTO.java
================
package com.jereczek.checkers.controller.dto;

import jakarta.annotation.Nonnull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ConnectRequestDTO {
    @Nonnull
    private PlayerDTO player;
    private String gameID;
}

================
File: java/com/jereczek/checkers/controller/dto/GameHistoryDto.java
================
package com.jereczek.checkers.controller.dto;

import com.jereczek.checkers.enums.PieceTypes;

import java.sql.Timestamp;

public record GameHistoryDto(
        String gameID,
        String opponent,
        PieceTypes winner,
        Timestamp startTime,
        boolean wasPvpGame
) {}

================
File: java/com/jereczek/checkers/controller/dto/GamePlayDTO.java
================
package com.jereczek.checkers.controller.dto;

import lombok.Data;

import java.util.List;

@Data
public class GamePlayDTO {
    private List<MoveDTO> moves;
    private String gameID;
    private String playerID;
}

================
File: java/com/jereczek/checkers/controller/dto/GameStartDTO.java
================
package com.jereczek.checkers.controller.dto;

import jakarta.annotation.Nullable;
import lombok.Data;

@Data
public class GameStartDTO {
    private String playerID;
    private boolean pvp;
    @Nullable
    private Integer difficulty;
}

================
File: java/com/jereczek/checkers/controller/dto/MoveDTO.java
================
package com.jereczek.checkers.controller.dto;

import com.jereczek.checkers.game.Move;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import static com.jereczek.checkers.game.model.board.Coordinates.coordinatesToSquareNumber;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MoveDTO {
    private int startPos;
    private int endPos;

    public MoveDTO(Move move) {
        this.startPos = coordinatesToSquareNumber(move.startX(), move.startY());
        this.endPos = coordinatesToSquareNumber(move.endX(), move.endY());
    }
}

================
File: java/com/jereczek/checkers/controller/dto/PlayerDTO.java
================
package com.jereczek.checkers.controller.dto;

import lombok.Data;

@Data
public class PlayerDTO {
    private String playerID;
}

================
File: java/com/jereczek/checkers/controller/GameController.java
================
package com.jereczek.checkers.controller;

import com.jereczek.checkers.controller.dto.ConnectRequestDTO;
import com.jereczek.checkers.controller.dto.GamePlayDTO;
import com.jereczek.checkers.controller.dto.GameStartDTO;
import com.jereczek.checkers.exception.IllegalPlayerException;
import com.jereczek.checkers.exception.connection.AllPlayersConnectedException;
import com.jereczek.checkers.exception.connection.GameFinishedException;
import com.jereczek.checkers.exception.connection.GameNotFoundException;
import com.jereczek.checkers.model.GameEntity;
import com.jereczek.checkers.service.GameService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.Optional;
import java.util.concurrent.ExecutorService;

import static com.jereczek.checkers.config.WebsocketConfiguration.GAME_PROGRESS_TOPIC;
import static com.jereczek.checkers.config.WebsocketConfiguration.GAME_TIPS_TOPIC;

@RestController
@Slf4j
@CrossOrigin
@RequestMapping("/game")
public class GameController {
    private final GameService gameService;

    private final SimpMessagingTemplate simpMessagingTemplate;

    public GameController(GameService gameService, SimpMessagingTemplate simpMessagingTemplate, ExecutorService asyncCpuExecutorService) {
        this.gameService = gameService;
        this.simpMessagingTemplate = simpMessagingTemplate;
    }

    @PostMapping("/start")
    public ResponseEntity<GameEntity> startGame(@RequestBody @Validated GameStartDTO startDTO) {
        log.debug("Start game request with player: {}", startDTO);
        GameEntity game = gameService.createGame(startDTO);
        simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + game.getGameID(), game);
        return ResponseEntity.ok(game);
    }

    @PostMapping("/connect")
    public ResponseEntity<GameEntity> connectToGame(@RequestBody @Validated ConnectRequestDTO connectRequest)
            throws AllPlayersConnectedException, GameNotFoundException, GameFinishedException {
        GameEntity game;
        if (connectRequest.getGameID() != null) {
            log.debug("Trying to connect to game: {}", connectRequest.getGameID());
            game = gameService.connectToPvpGame(connectRequest.getPlayer(), connectRequest.getGameID());
            simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + game.getGameID(), game);
        } else {
            log.debug("Trying to connect to a random game");
            game = gameService.connectToRandomGame(connectRequest.getPlayer());
            simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + game.getGameID(), game);
        }
        return ResponseEntity.ok(game);
    }

    @PostMapping("/gameplay")
    public ResponseEntity<GameEntity> makeMove(@RequestBody @Validated GamePlayDTO request) throws GameFinishedException, GameNotFoundException, IllegalPlayerException {
        log.debug("Making a move: {}", request);

        GameEntity afterPlayer = gameService.gamePlayPvp(request);
        simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + afterPlayer.getGameID(), afterPlayer);
        if (!afterPlayer.isPvpGame()) {
            runCpuMoveAsync(afterPlayer);
        } else {
            simpMessagingTemplate.convertAndSend(GAME_TIPS_TOPIC + afterPlayer.getGameID(), afterPlayer.getGameData());
        }
        return ResponseEntity.ok(afterPlayer);
    }

    @Async
    public void runCpuMoveAsync(GameEntity afterPlayer) {
        GameEntity game = gameService.gamePlayCpu(afterPlayer, Optional.ofNullable(afterPlayer.getDifficulty()).orElse(3));
        simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + game.getGameID(), game);
        var gameEntityWithTips = gameService.generateAndUpdateTips(game.getGameID());
        simpMessagingTemplate.convertAndSend(GAME_TIPS_TOPIC + gameEntityWithTips.getGameID(), gameEntityWithTips);
    }

    @GetMapping("/{id}")
    public ResponseEntity<GameEntity> getGame(@PathVariable String id) {
        try {
            GameEntity game = gameService.getGameState(id);
            simpMessagingTemplate.convertAndSend(GAME_PROGRESS_TOPIC + game.getGameID(), game);
            return ResponseEntity.ok(game);
        } catch (GameNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Game not found", e);
        }
    }
}

================
File: java/com/jereczek/checkers/controller/GameControllerExceptionHandler.java
================
package com.jereczek.checkers.controller;

import com.jereczek.checkers.exception.IllegalMoveException;
import com.jereczek.checkers.exception.IllegalPlayerException;
import org.springframework.http.HttpStatus;
import org.springframework.messaging.support.ErrorMessage;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GameControllerExceptionHandler {

    @ExceptionHandler(value = IllegalPlayerException.class)
    @ResponseStatus(value = HttpStatus.UNPROCESSABLE_ENTITY)
    public ErrorMessage message(IllegalPlayerException exception) {
        return new ErrorMessage(exception);
    }

    @ExceptionHandler(value = IllegalMoveException.class)
    @ResponseStatus(value = HttpStatus.UNPROCESSABLE_ENTITY)
    public ErrorMessage message(IllegalMoveException exception) {
        return new ErrorMessage(exception);
    }
}

================
File: java/com/jereczek/checkers/controller/GameHistoryController.java
================
package com.jereczek.checkers.controller;

import com.jereczek.checkers.controller.dto.GameHistoryDto;
import com.jereczek.checkers.model.GameEntity;
import com.jereczek.checkers.repositories.IGameRepo;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@CrossOrigin
@RequestMapping("/history")
public class GameHistoryController {
    private final IGameRepo gameRepo;

    public GameHistoryController(IGameRepo gameRepo) {
        this.gameRepo = gameRepo;
    }

    @GetMapping("/{playerID}")
    public ResponseEntity<List<GameHistoryDto>> getGameHistory(@PathVariable String playerID) {
        UUID playerUUID = UUID.fromString(playerID);
        Pageable pageRequest = PageRequest.of(0, 20, Sort.by(Sort.Direction.DESC, "startTime"));

        var history = gameRepo.findGamesByPlayer(playerUUID, pageRequest)
                .getContent()
                .stream()
                .map(game -> new GameHistoryDto(
                        game.getGameID(),
                        getOpponentName(game, playerID),
                        game.getWinner(),
                        game.getStartTime(),
                        game.isPvpGame()
                ))
                .collect(Collectors.toList());
        return ResponseEntity.ok(history);
    }

    private String getOpponentName(GameEntity game, String playerID) {
        if (game.getPlayer1().getPlayerID().toString().equals(playerID)) {
            return game.isPvpGame() ? game.getPlayer2().getUsername() : "CPU";
        } else {
            return game.getPlayer1().getUsername();
        }
    }
}

================
File: java/com/jereczek/checkers/controller/RegisterController.java
================
package com.jereczek.checkers.controller;

import com.jereczek.checkers.model.players.PlayerHuman;
import com.jereczek.checkers.service.PlayerService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RequiredArgsConstructor
@RestController
@RequestMapping("/register")
@CrossOrigin
public class RegisterController {
    private final PlayerService playerService;

    @PostMapping
    public ResponseEntity<?> registerPlayer(@RequestBody PlayerHuman playerHuman) {
        playerService.registerNewPlayer(playerHuman);
        return ResponseEntity.ok("Player registered successfully");
    }
}

================
File: java/com/jereczek/checkers/enums/GameStatus.java
================
package com.jereczek.checkers.enums;

public enum GameStatus {
    NEW, IN_PROGRESS, FINISHED
}

================
File: java/com/jereczek/checkers/enums/PieceTypes.java
================
package com.jereczek.checkers.enums;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

@Getter
public enum PieceTypes {
    EMPTY(0), WHITE(1), BLACK(2), WHITE_KING(7), BLACK_KING(8), CAPTURED(11);

    private static final Map<Integer, PieceTypes> BY_VALUE = new HashMap<>();

    static {
        for (PieceTypes e : values()) {
            BY_VALUE.put(e.value, e);
        }
    }

    private final Integer value;

    PieceTypes(Integer value) {
        this.value = value;
    }

    public static PieceTypes valueOfFigure(Integer value) {
        return BY_VALUE.get(value);
    }

    public boolean isRegularPiece() {
        return this == PieceTypes.WHITE || this == PieceTypes.BLACK;
    }

    public boolean isKingPiece() {
        return this == PieceTypes.WHITE_KING || this == PieceTypes.BLACK_KING;
    }
}

================
File: java/com/jereczek/checkers/enums/PlayerTypes.java
================
package com.jereczek.checkers.enums;

public enum PlayerTypes {
    HUMAN, CPU
}

================
File: java/com/jereczek/checkers/exception/connection/AllPlayersConnectedException.java
================
package com.jereczek.checkers.exception.connection;

public class AllPlayersConnectedException extends GameConnectionError {

    public static final String BOTH_PLAYERS_CONNECTED_MESSAGE_TEMPLATE = "Both players are already connected to the game: %s";

    public AllPlayersConnectedException(String gameID) {
        super(String.format(BOTH_PLAYERS_CONNECTED_MESSAGE_TEMPLATE, gameID));
    }

}

================
File: java/com/jereczek/checkers/exception/connection/GameConnectionError.java
================
package com.jereczek.checkers.exception.connection;

public class GameConnectionError extends RuntimeException {
    public GameConnectionError(String message) {
        super(message);
    }
}

================
File: java/com/jereczek/checkers/exception/connection/GameFinishedException.java
================
package com.jereczek.checkers.exception.connection;

public class GameFinishedException extends GameConnectionError {
    private static final String GAME_FINISHED_EXCEPTION_MESSAGE = "Game is already finished!";

    public GameFinishedException() {
        super(GAME_FINISHED_EXCEPTION_MESSAGE);
    }
}

================
File: java/com/jereczek/checkers/exception/connection/GameNotFoundException.java
================
package com.jereczek.checkers.exception.connection;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GameNotFoundException extends GameConnectionError {
    private final static String GAME_NOT_FOUND_EXCEPTION_TEMPLATE = "Game with id: %s not found";

    public GameNotFoundException(String gameID) {
        super(String.format(GAME_NOT_FOUND_EXCEPTION_TEMPLATE, gameID));
    }
}

================
File: java/com/jereczek/checkers/exception/IllegalMoveException.java
================
package com.jereczek.checkers.exception;

public class IllegalMoveException extends RuntimeException {
    public IllegalMoveException(String message) {
        super(message);
    }
}

================
File: java/com/jereczek/checkers/exception/IllegalPlayerException.java
================
package com.jereczek.checkers.exception;

public class IllegalPlayerException extends RuntimeException {
    public IllegalPlayerException(String message) {
        super(message);
    }
}

================
File: java/com/jereczek/checkers/game/ai/cache/BoardStateCacheService.java
================
package com.jereczek.checkers.game.ai.cache;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.stats.CacheStats;
import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.ai.evaluation.BoardEvaluator;
import com.jereczek.checkers.game.ai.movegenerator.MoveGenerator;
import com.jereczek.checkers.game.model.board.BoardState;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Component
@Slf4j
public class BoardStateCacheService {
    private final Cache<MiniMaxCacheKey, MiniMaxCacheEntry> cache;

    private final MoveGenerator moveGenerator;

    public BoardStateCacheService(Cache<MiniMaxCacheKey, MiniMaxCacheEntry> cache, MoveGenerator moveGenerator) {
        this.cache = cache;
        this.moveGenerator = moveGenerator;
    }

    public MiniMaxCacheEntry getAndInsertCache(BoardState boardState) {
        return cache.get(new MiniMaxCacheKey(boardState.getBoardArray(), boardState.getCurrentPlayer()),
                key -> generateCacheEntry(boardState));
    }

    public Optional<MiniMaxCacheEntry> getOptional(BoardState boardState) {
        return Optional.ofNullable(cache.getIfPresent(new MiniMaxCacheKey(boardState.getBoardArray(), boardState.getCurrentPlayer())));
    }

    private MiniMaxCacheEntry generateCacheEntry(BoardState boardState) {
        PieceTypes originalPlayer = boardState.getCurrentPlayer();

        boardState.setCurrentPlayer(PieceTypes.WHITE);
        List<List<Move>> whiteMoves = moveGenerator.generateMoves(boardState);

        boardState.setCurrentPlayer(PieceTypes.BLACK);
        List<List<Move>> blackMoves = moveGenerator.generateMoves(boardState);

        boardState.setCurrentPlayer(originalPlayer);
        Integer evaluation = evaluatePosition(boardState);

        return new MiniMaxCacheEntry(evaluation, whiteMoves, blackMoves);
    }

    private Integer evaluatePosition(BoardState boardState) {
        BoardEvaluator evaluator = new BoardEvaluator(boardState);
        return evaluator.evaluateBoard();
    }

    public CacheStats getStats() {
        return cache.stats();
    }
}

================
File: java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheConfig.java
================
package com.jereczek.checkers.game.ai.cache;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class MiniMaxCacheConfig {
    @Bean
    public Cache<MiniMaxCacheKey, MiniMaxCacheEntry> miniMaxCache() {
        return Caffeine.newBuilder()
                .expireAfterAccess(Duration.ofMinutes(5))
                .recordStats()
                .build();
    }
}

================
File: java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheEntry.java
================
package com.jereczek.checkers.game.ai.cache;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.piece.Piece;

import java.util.List;

public record MiniMaxCacheEntry(Integer evaluation, List<List<Move>> whiteMoves, List<List<Move>> blackMoves) {
    public List<List<Move>> getPossibleMoves(PieceTypes player) {
        return switch(player) {
            case WHITE -> whiteMoves;
            case BLACK -> blackMoves;
            default -> throw new IllegalArgumentException("Requested possible moves for invalid player type");
        };
    }
}

================
File: java/com/jereczek/checkers/game/ai/cache/MiniMaxCacheKey.java
================
package com.jereczek.checkers.game.ai.cache;

import com.jereczek.checkers.enums.PieceTypes;

import java.util.Arrays;
import java.util.Objects;

public record MiniMaxCacheKey(int[][] boardArray, PieceTypes currentPlayer) {
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MiniMaxCacheKey that = (MiniMaxCacheKey) o;
        return Arrays.deepEquals(boardArray, that.boardArray) &&
                currentPlayer == that.currentPlayer;
    }

    @Override
    public int hashCode() {
        return Objects.hash(Arrays.deepHashCode(boardArray), currentPlayer);
    }
}

================
File: java/com/jereczek/checkers/game/ai/evaluation/BoardEvaluator.java
================
package com.jereczek.checkers.game.ai.evaluation;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.game.model.board.Coordinates;

import java.util.Map;
import java.util.Set;

import static com.jereczek.checkers.enums.PieceTypes.*;
import static com.jereczek.checkers.game.ai.evaluation.EvaluationConstants.*;
import static com.jereczek.checkers.game.ai.evaluation.PositionsConstants.*;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;

public class BoardEvaluator {
    private final BoardState boardState;

    public BoardEvaluator(BoardState boardState) {
        this.boardState = boardState;
    }

    public Integer evaluateBoard() {
        boolean isEndgame = isEndgame(boardState);

        int whiteScore = evaluatePhase(boardState.getWhitePieces(), isEndgame) +
                evaluateFormation(boardState.getWhitePieces());

        int blackScore = evaluatePhase(boardState.getBlackPieces(), isEndgame) +
                evaluateFormation(boardState.getBlackPieces());

        return whiteScore - blackScore;
    }

    private int pieceValue(PieceTypes type, Integer position, boolean isEndgame) {
        int value;

        if (type.isRegularPiece()) {
            value = PIECE_VALUE;
            Coordinates coords = Coordinates.fromSquareNumber(position);
            int advancement = (type == WHITE) ?
                    (BOARD_DIMENSION - 1 - coords.y()) :
                    coords.y();
            value += advancement * ADVANCEMENT_BONUS;
        } else {
            value = evaluateKing(position, isEndgame);
        }

        if (!isEndgame) {
            if (type.isRegularPiece() && isBackRow(type, position)) {
                value += BACK_ROW_PIECE_BONUS;
            }

            if (isControllingMiddle(position)) {
                value += (int) (value * CENTER_MODIFIER);
            }

            if (SAFE_COLUMNS.contains(position)) {
                value += SAFE_COLUMN_BONUS;
            }
        }

        if (isInDanger(position, type)) {
            value = (int) (value * DANGER_MODIFIER);
        }

        if (type.isRegularPiece() &&
                SAFE_COLUMNS.contains(position) &&
                isControllingMiddle(position)) {
            value += SAFE_COLUMN_BONUS / 2;
        }

        if (isEndgame) {
            if (type == WHITE_KING || type == BLACK_KING) {
                value *= 1.5;
            }

            if (isControllingMiddle(position)) {
                value += 25;
            }

            if (type.isRegularPiece()) {
                Coordinates coords = Coordinates.fromSquareNumber(position);
                int distanceToPromotion = (type == WHITE) ? coords.y() : (BOARD_DIMENSION - 1 - coords.y());
                if (distanceToPromotion <= 2) {
                    value += (3 - distanceToPromotion) * 30;
                }
            }
        }

        return value;
    }

    private boolean isControllingMiddle(Integer position) {
        return CENTER_SQUARES.contains(position);
    }

    private boolean isBackRow(PieceTypes pieceTypes, Integer position) {
        if (pieceTypes.isRegularPiece()) {
            return (pieceTypes == WHITE) ? WHITE_BACK_ROW.contains(position) : BLACK_BACK_ROW.contains(position);
        }
        return false;
    }

    private boolean isInDanger(Integer position, PieceTypes piece) {
        if (SAFE_COLUMNS.contains(position)) {
            return false;
        }
        Map<Integer, PieceTypes> opponentPieces;

        opponentPieces = (piece == WHITE || piece == WHITE_KING) ? boardState.getBlackPieces() : boardState.getWhitePieces();

        int[] directions = getAdjacentDirections(position);

        for (int dir : directions) {
            Integer diagonalAdjacent = position + dir;
            if (isOpponentPiece(diagonalAdjacent, opponentPieces) && isEmptySquare(position + 2 * dir)) {
                return true;
            }
        }
        return false;
    }

    private int[] getAdjacentDirections(Integer position) {
        boolean isEvenRow = ((position - 1) / 5) % 2 == 0;
        if (isEvenRow) {
            return new int[]{-4, -5, 5, 6};
        } else {
            return new int[]{-6, -5, 4, 5};
        }
    }

    private boolean isOpponentPiece(Integer position, Map<Integer, PieceTypes> opponentPieces) {
        return opponentPieces.containsKey(position);
    }

    private boolean isEmptySquare(Integer position) {
        return !boardState.getWhitePieces().containsKey(position) && boardState.getBlackPieces().containsKey(position);
    }

    private boolean isEndgame(BoardState state) {
        int totalPieces = state.getWhitePieces().size() + state.getBlackPieces().size();
        return totalPieces <= 8;
    }

    private int evaluatePhase(Map<Integer, PieceTypes> piecesMap, boolean isEndgame) {
        int value = 0;
        for (Map.Entry<Integer, PieceTypes> piece : piecesMap.entrySet()) {
            value += pieceValue(piece.getValue(), piece.getKey(), isEndgame);
        }
        return value;
    }

    private int evaluateFormation(Map<Integer, PieceTypes> pieces) {
        int formationValue = 0;
        Set<Integer> piecesPositions = pieces.keySet();

        for (Integer pos : piecesPositions) {
            if (piecesPositions.contains(pos + 5) ||
                    piecesPositions.contains(pos + 6) ||
                    piecesPositions.contains(pos - 5) ||
                    piecesPositions.contains(pos - 6)) {
                formationValue += FORMATION_BONUS;
            }
        }
        return formationValue;
    }

    private int evaluateKing(int position, boolean isEndgame) {
        int value = KING_VALUE;

        if (isEndgame) {
            if (isControllingMiddle(position)) {
                value *= ENDGAME_KING_CENTER_MODIFIER;
            }
            value += evaluateKingPosition(position);
        }

        return value;
    }

    private int evaluateKingPosition(int position) {
        Coordinates coords = Coordinates.fromSquareNumber(position);
        int centerDistance = Math.abs(coords.x() - 5) + Math.abs(coords.y() - 5);
        return (10 - centerDistance) * 10;
    }
}

================
File: java/com/jereczek/checkers/game/ai/evaluation/EvaluationConstants.java
================
package com.jereczek.checkers.game.ai.evaluation;

public class EvaluationConstants {
    public static final int PIECE_VALUE = 100;

    public static final int KING_VALUE = 200;

    public static final int BACK_ROW_PIECE_BONUS = 20;

    public static final int SAFE_COLUMN_BONUS = 30;

    public static final int FORMATION_BONUS = 25;

    public static final int ADVANCEMENT_BONUS = 10;

    public static final float CENTER_MODIFIER = 0.5F;

    public static final float DANGER_MODIFIER = 0.3F;

    public static final float ENDGAME_KING_CENTER_MODIFIER = 1.5f;
}

================
File: java/com/jereczek/checkers/game/ai/evaluation/PositionsConstants.java
================
package com.jereczek.checkers.game.ai.evaluation;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class PositionsConstants {
    public static final Set<Integer> BLACK_BACK_ROW = Stream.of(46, 47, 48, 49, 50)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Integer> WHITE_BACK_ROW = Stream.of(1, 2, 3, 4, 5)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Integer> CENTER_SQUARES = Stream.of(28, 29, 22, 23, 27, 24)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Integer> SAFE_COLUMNS = Stream.of(5, 15, 25, 35, 45,
            6, 16, 26, 36, 46).collect(Collectors.toCollection(HashSet::new));
}

================
File: java/com/jereczek/checkers/game/ai/MiniMax.java
================
package com.jereczek.checkers.game.ai;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.CheckersGameLogic;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.ai.cache.BoardStateCacheService;
import com.jereczek.checkers.game.ai.cache.MiniMaxCacheEntry;
import com.jereczek.checkers.game.ai.evaluation.BoardEvaluator;
import com.jereczek.checkers.game.model.board.BoardState;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.util.List;

import static com.jereczek.checkers.enums.PieceTypes.WHITE;

@Slf4j
@Service
public class MiniMax {
    private static final Duration TIMEOUT_AFTER = Duration.ofSeconds(30);
    private final CheckersGameLogic checkersGameLogic;

    private final BoardStateCacheService cacheService;

    public MiniMax(CheckersGameLogic checkersGameLogic, BoardStateCacheService cacheService) {
        this.checkersGameLogic = checkersGameLogic;
        this.cacheService = cacheService;
    }

    public MiniMaxNode miniMax(BoardState boardState, int depth, PieceTypes maximizingPlayer) {
        Instant timeoutAfter = Instant.now().plus(TIMEOUT_AFTER);
        Instant start = Instant.now();
        MiniMaxNode miniMaxNode = miniMax(boardState, depth, maximizingPlayer, Integer.MIN_VALUE, Integer.MAX_VALUE, timeoutAfter );
        log.debug("\nMinimax duration: {}\n", Duration.between(start, Instant.now()));
        return miniMaxNode;
    }

    public MiniMaxNode miniMax(BoardState boardState, int depth, PieceTypes maximizingPlayer, int alpha, int beta, Instant timeoutAfter) {
        if (depth == 0 || Instant.now().isAfter(timeoutAfter)) {
            return new MiniMaxNode(evaluatePosition(boardState, maximizingPlayer), null);
        }
        if (checkersGameLogic.checkWinner(boardState).isPresent()) {
            if (maximizingPlayer == WHITE) {
                return new MiniMaxNode(boardState.getWhitePieces().isEmpty() ? -20000 : 20000, null);
            } else
                return new MiniMaxNode(boardState.getBlackPieces().isEmpty() ? -20000 : 20000, null);
        }

        MiniMaxCacheEntry cacheEntry = cacheService.getAndInsertCache(boardState);
        List<List<Move>> possibleMoveSequences = cacheEntry.getPossibleMoves(boardState.getCurrentPlayer());

        List<Move> bestMoveSequence = null;
        int bestScore = (boardState.getCurrentPlayer() == maximizingPlayer) ? Integer.MIN_VALUE : Integer.MAX_VALUE;

        for (List<Move> moveSequence : possibleMoveSequences) {
            BoardState newBoardState = new BoardState(boardState);
            newBoardState = checkersGameLogic.doMovements(moveSequence, newBoardState, false);
            MiniMaxNode result = miniMax(newBoardState, depth - 1, maximizingPlayer, alpha, beta, timeoutAfter);
            if (boardState.getCurrentPlayer() == maximizingPlayer) {
                if (result.score > bestScore) {
                    bestScore = result.score;
                    bestMoveSequence = moveSequence;
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) {
                        break; // Beta cut-off
                    }
                }
            } else {
                if (result.score < bestScore) {
                    bestScore = result.score;
                    bestMoveSequence = moveSequence;
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) {
                        break; // Alpha cut-off
                    }
                }
            }
        }
        return new MiniMaxNode(bestScore, bestMoveSequence);
    }

    private Integer evaluatePosition(BoardState boardState, PieceTypes maximizingPlayer) {
        Integer evaluation = cacheService.getOptional(boardState)
                .map(MiniMaxCacheEntry::evaluation)
                .orElse(new BoardEvaluator(boardState).evaluateBoard());
        return maximizingPlayer == WHITE ? evaluation : -evaluation;
    }
}

================
File: java/com/jereczek/checkers/game/ai/MiniMaxNode.java
================
package com.jereczek.checkers.game.ai;

import com.jereczek.checkers.game.Move;
import lombok.Data;

import java.util.List;

@Data
public class MiniMaxNode {
    int score;
    List<Move> bestMoveSequence;

    public MiniMaxNode(int score, List<Move> bestMoveSequence) {
        this.score = score;
        this.bestMoveSequence = bestMoveSequence;
    }
}

================
File: java/com/jereczek/checkers/game/ai/movegenerator/MoveGenerator.java
================
package com.jereczek.checkers.game.ai.movegenerator;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.LongestCaptureCalculator;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.ai.MoveValidator;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.game.model.board.Coordinates;
import com.jereczek.checkers.game.model.board.constants.BoardConstants;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static com.jereczek.checkers.game.KingMoveValidator.checkIfCorrectLongKingMove;
import static com.jereczek.checkers.game.model.board.BoardUtils.isSquareEmptyAndWithinBoard;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;

@Slf4j
@Service
public class MoveGenerator {
    private final LongestCaptureCalculator longestCaptureCalculator;

    private final MoveValidator moveValidator;

    public MoveGenerator(MoveValidator moveValidator, LongestCaptureCalculator longestCaptureCalculator) {
        this.moveValidator = moveValidator;
        this.longestCaptureCalculator = longestCaptureCalculator;
    }

    public List<List<Move>> generateMoves(BoardState boardState) {
        List<List<Move>> validMoves = new ArrayList<>();
        if (longestCaptureCalculator.isCaptureAvailable(boardState)) {
            return longestCaptureCalculator.getLongestCapturesList(boardState);
        }

        for (Map.Entry<Integer, PieceTypes> piece : boardState.getCurrentPlayerPieces().entrySet()) {
            int piecePosition = piece.getKey();
            PieceTypes pieceType = piece.getValue();
            List<Move> potentialMoves = generatePotentialMovesForPiece(piecePosition, pieceType, boardState);

            for (Move move : potentialMoves) {
                if (moveValidator.isMoveLegal(boardState, move, pieceType, false).isEmpty()) {
                    validMoves.add(List.of(move));
                }
            }
        }
        return validMoves;
    }

    private List<Move> generatePotentialMovesForPiece(int piecePosition, PieceTypes pieceType, BoardState boardState) {
        List<Move> potentialMoves = new ArrayList<>();
        Coordinates coords = Coordinates.fromSquareNumber(piecePosition);
        if (pieceType.isRegularPiece()) {
            potentialMoves.addAll(generateRegularMoves(coords, boardState));
        } else if (pieceType.isKingPiece()) {
            potentialMoves.addAll(generateKingMoves(coords, boardState));
        }
        return potentialMoves;
    }

    private List<Move> generateKingMoves(Coordinates coords, BoardState boardState) {
        List<Move> kingMoves = new ArrayList<>();
        for (int[] direction : BoardConstants.POSSIBLE_DIRECTIONS) {
            for (int distance = 1; distance <= BOARD_DIMENSION; distance++) {
                var newCoords = new Coordinates(coords.x() + direction[0] * distance,
                        coords.y() + direction[1] * distance);

                if (isSquareEmptyAndWithinBoard(newCoords, boardState.getBoardArray())) {
                    Move move = new Move(coords.x(), coords.y(), newCoords.x(), newCoords.y());
                    if (checkIfCorrectLongKingMove(boardState.getBoardArray(), move, distance)) {
                        kingMoves.add(move);
                    }
                } else {
                    break;
                }
            }
        }
        return kingMoves;
    }

    private List<Move> generateRegularMoves(Coordinates coords, BoardState boardState) {
        List<Move> regularMoves = new ArrayList<>();
        for (int[] direction : BoardConstants.POSSIBLE_DIRECTIONS) {
            var newCoords = new Coordinates(coords.x() + direction[0], coords.y() + direction[1]);

            if (isSquareEmptyAndWithinBoard(newCoords, boardState.getBoardArray())) {
                regularMoves.add(new Move(coords.x(), coords.y(), newCoords.x(), newCoords.y()));
            }
        }
        return regularMoves;
    }
}

================
File: java/com/jereczek/checkers/game/ai/MoveValidator.java
================
package com.jereczek.checkers.game.ai;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.exception.IllegalMoveException;
import com.jereczek.checkers.game.KingMoveValidator;
import com.jereczek.checkers.game.LongestCaptureCalculator;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.model.board.BoardState;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

import static com.jereczek.checkers.game.model.board.Coordinates.coordinatesToSquareNumber;

@Slf4j
@Service
public class MoveValidator {
    private final LongestCaptureCalculator longestCaptureCalculator;

    public MoveValidator(LongestCaptureCalculator longestCaptureCalculator) {
        this.longestCaptureCalculator = longestCaptureCalculator;
    }

    public Optional<RuntimeException> isMoveLegal(BoardState board, Move move, PieceTypes piece, boolean isCapture) {
        int distanceX = Math.abs(move.endX() - move.startX());
        int distanceY = Math.abs(move.endY() - move.startY());

        if (piece == PieceTypes.EMPTY) {
            return Optional.of(new IllegalMoveException("No Piece on starting position!"));
        }

        if (board.getBoardArray()[move.endY()][move.endX()] != PieceTypes.EMPTY.getValue()) {
            return Optional.of(new IllegalMoveException("Ending Position not empty!"));
        }

        if (distanceX != distanceY) {
            return Optional.of(new IllegalMoveException("Move is not diagonal!"));
        }
        if ((piece == PieceTypes.WHITE && move.endY() > move.startY())
                || (piece == PieceTypes.BLACK && move.endY() < move.startY())) {
            if (distanceX == 1)
                return Optional.of(new IllegalMoveException("Piece " +
                        coordinatesToSquareNumber(move.startX(), move.startY()) + " tried to move backwards!"));
        }

        if (distanceX > 2 && (piece != PieceTypes.WHITE_KING && piece != PieceTypes.BLACK_KING)) {
            return Optional.of(new IllegalMoveException("Move was too long for a pawn!!"));
        }
        if (distanceX == 2 && (piece != PieceTypes.WHITE_KING && piece != PieceTypes.BLACK_KING)) {
            if (!isCapture)
                return Optional.of(new IllegalMoveException("Move was too long for a pawn!"));
        }

        if ((piece == PieceTypes.WHITE_KING || piece == PieceTypes.BLACK_KING) && distanceX > 1) {
            if (!isCapture)
                if (!KingMoveValidator.checkIfCorrectLongKingMove(board.getBoardArray(), move, distanceX)) {
                    return Optional.of(new IllegalMoveException("King tried to move over an ally piece or multiple enemy pieces"));
                }
        }
        return Optional.empty();
    }


    public void checkIfLongestCapture(List<Move> moves, BoardState boardState) {
        if (!longestCaptureCalculator.isCaptureAvailable(boardState)) {
            return;
        }
        List<List<Move>> longestSequenceAvailable = longestCaptureCalculator.getLongestCapturesList(boardState);
        if (!longestSequenceAvailable.getFirst().isEmpty()) {
            if (!longestSequenceAvailable.contains(moves)) {
                throw new IllegalMoveException("Longer capture sequence available than move");
            }
        }
    }
}

================
File: java/com/jereczek/checkers/game/CheckersGameLogic.java
================
package com.jereczek.checkers.game;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.ai.MoveValidator;
import com.jereczek.checkers.game.ai.cache.BoardStateCacheService;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.game.model.board.Coordinates;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

import static com.jereczek.checkers.enums.PieceTypes.*;
import static com.jereczek.checkers.game.model.board.BoardUtils.isOppositePiece;
import static com.jereczek.checkers.game.model.board.Coordinates.coordinatesToSquareNumber;

@Slf4j
@Service
public class CheckersGameLogic {
    private final MoveValidator moveValidator;

    private final BoardStateCacheService boardStateCacheService;

    public CheckersGameLogic(MoveValidator moveValidator, BoardStateCacheService boardStateCacheService) {
        this.moveValidator = moveValidator;
        this.boardStateCacheService = boardStateCacheService;
    }

    public Optional<PieceTypes> checkWinner(BoardState boardState) {
        if (boardState.getWhitePieces().isEmpty()) {
            return Optional.of(BLACK);
        }
        if (boardState.getBlackPieces().isEmpty()) {
            return Optional.of(WHITE);
        }
        List<List<Move>> availableMoves = boardStateCacheService.getAndInsertCache(boardState)
                .getPossibleMoves(boardState.getCurrentPlayer());
        if (availableMoves.isEmpty()) {
            return Optional.of(boardState.getCurrentPlayer() == WHITE ? BLACK : WHITE);
        }
        return Optional.empty();
    }

    public BoardState doMovements(List<Move> moves, BoardState boardState, boolean validate) {
        var capturedPieces = new LinkedList<Coordinates>();
        if (validate) {
            moveValidator.checkIfLongestCapture(moves, boardState);
        }
        PieceTypes movingPieceType = valueOfFigure(boardState.getBoardArray()[moves.getFirst().startY()][moves.getFirst().startX()]);
        for (Move move : moves) {
            var isCapture = checkIfMoveIsCapture(boardState, move, movingPieceType);

            moveValidator.isMoveLegal(boardState, move, movingPieceType, isCapture).ifPresent(exc -> {
                throw exc;
            });

            if (isCapture) {
                capturePiece(move, boardState, capturedPieces);
            }
            boardState.movePiece(move, movingPieceType);
        }

        boardState.cleanupCaptured(capturedPieces);

        promotePiece(boardState, moves.getLast(), movingPieceType);

        boardState.setCurrentPlayer(GameStateUtils.getNextPlayerType(boardState.getCurrentPlayer()));
        return boardState;
    }

    private void capturePiece(Move move, BoardState boardState, List<Coordinates> capturedPieces) {
        int distanceX = Math.abs(move.endX() - move.startX());
        int stepX = (move.endX() - move.startX()) / distanceX;
        int stepY = (move.endY() - move.startY()) / distanceX;
        for (int i = 1; i < distanceX; i++) {
            var captured = new Coordinates(move.startX() + i * stepX, move.startY() + i * stepY);
            if (boardState.getBoardArray()[captured.y()][captured.x()] != PieceTypes.EMPTY.getValue()) {
                boardState.markCaptured(captured);
                capturedPieces.add(captured);
            }
        }
    }

    private void promotePiece(BoardState boardState, Move move, PieceTypes pieceType) {
        if ((pieceType == PieceTypes.WHITE && move.endY() == 0)
                || (pieceType == PieceTypes.BLACK && move.endY() == boardState.getBoardArray().length - 1)) {
            pieceType = (pieceType == PieceTypes.WHITE) ? PieceTypes.WHITE_KING : PieceTypes.BLACK_KING;
            boardState.getBoardArray()[move.endY()][move.endX()] = pieceType.getValue();

            if (pieceType == PieceTypes.BLACK_KING) {
                boardState.getBlackPieces().replace(coordinatesToSquareNumber(move.endX(), move.endY()), pieceType);
            } else {
                boardState.getWhitePieces().replace(coordinatesToSquareNumber(move.endX(), move.endY()), pieceType);
            }
        }
    }

    public boolean checkIfMoveIsCapture(BoardState boardState, Move move, PieceTypes movingPieceType) {
        int distanceX = Math.abs(move.endX() - move.startX());
        if (distanceX == 2 && movingPieceType.isRegularPiece()) {
            PieceTypes middlePiece = valueOfFigure(boardState.getBoardArray()[(move.startY() + move.endY()) / 2][(move.startX() + move.endX()) / 2]);
            return isOppositePiece(boardState.getCurrentPlayer(), middlePiece);
        } else if (movingPieceType.isKingPiece()) {
            return KingMoveValidator.checkIfCorrectLongKingCapture(boardState.getBoardArray(), move);
        }
        return false;
    }
}

================
File: java/com/jereczek/checkers/game/GameStateUtils.java
================
package com.jereczek.checkers.game;

import com.jereczek.checkers.controller.dto.GamePlayDTO;
import com.jereczek.checkers.enums.GameStatus;
import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.exception.IllegalMoveException;
import com.jereczek.checkers.exception.IllegalPlayerException;
import com.jereczek.checkers.exception.connection.GameFinishedException;
import com.jereczek.checkers.game.model.board.BoardMapper;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.model.GameEntity;
import lombok.extern.slf4j.Slf4j;

import static com.jereczek.checkers.enums.PieceTypes.WHITE;

@Slf4j
public class GameStateUtils {
    public static PieceTypes getNextPlayerType(PieceTypes currentPlayer) {
        return currentPlayer.equals(PieceTypes.WHITE) ? PieceTypes.BLACK : PieceTypes.WHITE;
    }

    public static BoardState validateAndGetBoardState(GameEntity game, GamePlayDTO gamePlayDTO) {
        validateGameStatus(game);

        BoardState boardState = BoardMapper.entityToBoardStateMapper(game.getBoardStateEntity());
        PieceTypes expectedType = game.getBoardStateEntity().getCurrentPlayer();
        var expectedPlayer = expectedType.equals(WHITE) ? game.getPlayer1() : game.getPlayer2();
        validateCorrectPlayerTurn(boardState, gamePlayDTO, expectedPlayer.getPlayerID().toString(), expectedType);
        return boardState;
    }

    public static void validateCorrectPlayerTurn(BoardState boardState,
                                                 GamePlayDTO gamePlayDTO,
                                                 String expectedPlayerId,
                                                 PieceTypes expectedType) {
        if (!expectedPlayerId.equals(gamePlayDTO.getPlayerID())) {
            throw new IllegalPlayerException(String.format("Received move for %s player, but received: %s", expectedPlayerId, gamePlayDTO.getPlayerID()));
        }
        int startPos = gamePlayDTO.getMoves().getFirst().getStartPos();
        var isCorrectPlayerType = expectedType.equals(WHITE) ? boardState.getWhitePieces().containsKey(startPos) :
                boardState.getBlackPieces().containsKey(startPos);
        if(!isCorrectPlayerType) {
            throw new IllegalMoveException(String.format("It's %s player turn, received turn for opponents", expectedType.name()));
        }
    }

    public static void validateGameStatus(GameEntity game) throws GameFinishedException {
        if (game.getGameStatus().equals(GameStatus.FINISHED)) {
            log.debug("Tried to connect to game: {}, but it's already finished!", game.getGameID());
            throw new GameFinishedException();
        }
    }
}

================
File: java/com/jereczek/checkers/game/KingMoveValidator.java
================
package com.jereczek.checkers.game;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.model.board.Coordinates;

import static com.jereczek.checkers.enums.PieceTypes.EMPTY;
import static com.jereczek.checkers.game.model.board.BoardUtils.isOppositePiece;
import static com.jereczek.checkers.game.model.board.BoardUtils.isSquareEmptyAndWithinBoard;

public class KingMoveValidator {
    public static boolean checkIfCorrectLongKingMove(int[][] board, Move move, int distanceX) {
        int stepX = (move.endX() - move.startX()) / distanceX;
        int stepY = (move.endY() - move.startY()) / distanceX;
        for (int i = 1; i < distanceX; i++) {
            int middleX = move.startX() + i * stepX;
            int middleY = move.startY() + i * stepY;
            if (board[middleY][middleX] != PieceTypes.EMPTY.getValue()) {
                return false;
            }
        }
        return true;
    }

    public static boolean checkIfCorrectLongKingCapture(int[][] board, Move move) {
        if (!isSquareEmptyAndWithinBoard(new Coordinates(move.endX(), move.endY()), board)) {
            return false;
        }

        int distanceX = Math.abs(move.endX() - move.startX());
        int distanceY = Math.abs(move.endY() - move.startY());
        int stepX = (move.endX() - move.startX()) / distanceX;
        int stepY = (move.endY() - move.startY()) / distanceY;
        int piecesInBetween = 0;
        for (int i = 1; i < distanceX; i++) {
            int middleX = move.startX() + i * stepX;
            int middleY = move.startY() + i * stepY;
            PieceTypes middlePiece = PieceTypes.valueOfFigure(board[middleY][middleX]);
            PieceTypes movingPiece = PieceTypes.valueOfFigure(board[move.startY()][move.startX()]);
            if (isOppositePiece(movingPiece, middlePiece)) {
                piecesInBetween++;
            }
            if (piecesInBetween > 1) return false;
            if (!isOppositePiece(movingPiece, middlePiece) && middlePiece != EMPTY) return false;
        }
        return piecesInBetween == 1;
    }
}

================
File: java/com/jereczek/checkers/game/LongestCaptureCalculator.java
================
package com.jereczek.checkers.game;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.game.model.board.BoardUtils;
import com.jereczek.checkers.game.model.board.Coordinates;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static com.jereczek.checkers.enums.PieceTypes.valueOfFigure;
import static com.jereczek.checkers.game.KingMoveValidator.checkIfCorrectLongKingCapture;
import static com.jereczek.checkers.game.model.board.BoardUtils.*;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.POSSIBLE_DIRECTIONS;

@Slf4j
@Component
public class LongestCaptureCalculator {
    public List<List<Move>> getLongestCapturesList(BoardState boardState) {
        List<List<Move>> longestSequences = new ArrayList<>();
        for (Map.Entry<Integer, PieceTypes> entry : boardState.getCurrentPlayerPieces().entrySet()) {
            Coordinates pieceCoords = Coordinates.fromSquareNumber(entry.getKey());
            List<List<Move>> availableCaptureSequences = findCaptureSequences(pieceCoords, boardState, entry.getValue(), new ArrayList<>());
            for (List<Move> sequence : availableCaptureSequences) {
                longestSequences = findLongestSequences(longestSequences, sequence);
            }
        }
        return longestSequences;
    }

    private List<List<Move>> findCaptureSequences(Coordinates startCoords, BoardState boardState,
                                                  PieceTypes pieceType, List<Coordinates> capturedPieces) {
        List<List<Move>> sequences = new ArrayList<>();

        if (pieceType.isRegularPiece()) {
            sequences.addAll(findRegularPieceCaptures(startCoords, boardState, pieceType, new ArrayList<>(), capturedPieces));
        } else if (pieceType.isKingPiece()) {
            sequences.addAll(findKingCaptures(startCoords, boardState, pieceType, new ArrayList<>(), capturedPieces));
        }

        return sequences.isEmpty() ? List.of(new ArrayList<>()) : sequences;
    }

    private List<List<Move>> findRegularPieceCaptures(Coordinates startCoords, BoardState boardState,
                                                      PieceTypes pieceType, List<Move> currentSequence, List<Coordinates> capturedPieces) {
        List<List<Move>> sequences = new ArrayList<>();

        for (int[] direction : POSSIBLE_DIRECTIONS) {
            Coordinates captureCoords = new Coordinates(startCoords.x() + direction[0],
                    startCoords.y() + direction[1]);
            Coordinates landingCoords = new Coordinates(captureCoords.x() + direction[0],
                    captureCoords.y() + direction[1]);

            if (!isValidCapture(boardState, captureCoords, landingCoords, pieceType, capturedPieces)) {
                continue;
            }

            BoardState newState = new BoardState(boardState);
            Move captureMove = new Move(startCoords.x(), startCoords.y(), landingCoords.x(), landingCoords.y());

            List<Coordinates> newCapturedPieces = new ArrayList<>(capturedPieces);
            newCapturedPieces.add(captureCoords);
            newState.markCaptured(captureCoords);
            newState.movePiece(captureMove, pieceType);

            List<Move> newSequence = new ArrayList<>(currentSequence);
            newSequence.add(captureMove);

            List<List<Move>> continuedCaptures = findCaptureSequences(landingCoords, newState,
                    pieceType, newCapturedPieces);

            if (continuedCaptures.isEmpty()) {
                sequences.add(newSequence);
            } else {
                for (List<Move> continuation : continuedCaptures) {
                    List<Move> completeSequence = new ArrayList<>(newSequence);
                    completeSequence.addAll(continuation);
                    sequences.add(completeSequence);
                }
            }
        }

        return sequences;
    }

    private List<List<Move>> findKingCaptures(Coordinates startCoords, BoardState boardState,
                                              PieceTypes pieceType, List<Move> currentSequence, List<Coordinates> capturedPieces) {
        List<List<Move>> sequences = new ArrayList<>();

        for (int[] direction : POSSIBLE_DIRECTIONS) {
            for (int distance = 1; distance < BOARD_DIMENSION; distance++) {
                Coordinates captureCoords = new Coordinates(startCoords.x() + direction[0] * distance,
                        startCoords.y() + direction[1] * distance);

                if (!isCoordinateWithinBoard(captureCoords) ||
                        capturedPieces.contains(captureCoords)) {
                    break;
                }

                Coordinates landingCoords = new Coordinates(captureCoords.x() + direction[0],
                        captureCoords.y() + direction[1]);

                if (!isValidKingCapture(boardState, startCoords, captureCoords, landingCoords, pieceType)) {
                    continue;
                }

                BoardState newState = new BoardState(boardState);
                Move captureMove = new Move(startCoords.x(), startCoords.y(), landingCoords.x(), landingCoords.y());

                List<Coordinates> newCapturedPieces = new ArrayList<>(capturedPieces);
                newCapturedPieces.add(captureCoords);
                newState.markCaptured(captureCoords);
                newState.movePiece(captureMove, pieceType);

                List<Move> newSequence = new ArrayList<>(currentSequence);
                newSequence.add(captureMove);

                List<List<Move>> continuedCaptures = findCaptureSequences(landingCoords, newState,
                        pieceType, newCapturedPieces);

                if (continuedCaptures.isEmpty()) {
                    sequences.add(newSequence);
                } else {
                    for (List<Move> continuation : continuedCaptures) {
                        List<Move> completeSequence = new ArrayList<>(newSequence);
                        completeSequence.addAll(continuation);
                        sequences.add(completeSequence);
                    }
                }
            }
        }

        return sequences;
    }

    private boolean isValidCapture(BoardState boardState, Coordinates captureCoords,
                                   Coordinates landingCoords, PieceTypes pieceType, List<Coordinates> capturedPieces) {
        if (!isCoordinateWithinBoard(captureCoords) ||
                !isCoordinateWithinBoard(landingCoords) ||
                capturedPieces.contains(captureCoords)) {
            return false;
        }

        PieceTypes capturePiece = PieceTypes.valueOfFigure(
                boardState.getBoardArray()[captureCoords.y()][captureCoords.x()]);

        return isMiddlePieceOpponentsAndLandingSquareEmpty(
                boardState.getBoardArray(), landingCoords, pieceType, capturePiece);
    }

    private boolean isValidKingCapture(BoardState boardState, Coordinates startCoords,
                                       Coordinates captureCoords, Coordinates landingCoords, PieceTypes pieceType) {
        if (!isValidCapturePosition(captureCoords, boardState.getBoardArray(), pieceType) ||
                !isSquareEmptyAndWithinBoard(landingCoords, boardState.getBoardArray())) {
            return false;
        }

        Move move = new Move(startCoords.x(), startCoords.y(), landingCoords.x(), landingCoords.y());
        return checkIfCorrectLongKingCapture(boardState.getBoardArray(), move);
    }

    private boolean isValidCapturePosition(Coordinates capturedPieceCoords, int[][] board, PieceTypes pieceType) {
        if (!BoardUtils.isCoordinateWithinBoard(capturedPieceCoords)) {
            return false;
        }
        PieceTypes pieceAtPosition = valueOfFigure(board[capturedPieceCoords.y()][capturedPieceCoords.x()]);
        return isOppositePiece(pieceType, pieceAtPosition);
    }

    public boolean isCaptureAvailable(BoardState boardState) {
        for (Map.Entry<Integer, PieceTypes> entry : boardState.getCurrentPlayerPieces().entrySet()) {
            Coordinates coords = Coordinates.fromSquareNumber(entry.getKey());
            PieceTypes pieceType = entry.getValue();

            if (pieceType == PieceTypes.WHITE || pieceType == PieceTypes.BLACK) {
                if (isRegularCaptureAvailable(boardState, coords)) {
                    return true;
                }
            } else {
                if (isKingCaptureAvailable(boardState.getBoardArray(), coords)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isKingCaptureAvailable(int[][] board, Coordinates coords) {
        for (int[] direction : POSSIBLE_DIRECTIONS) {
            int dx = direction[0];
            int dy = direction[1];
            for (int steps = 1; steps < BOARD_DIMENSION; steps++) {
                var checkCoords = new Coordinates(coords.x() + dx * steps, coords.y() + dy * steps);
                var landing = new Coordinates(checkCoords.x() + dx, checkCoords.y() + dy);
                if (!isCoordinateWithinBoard(landing)) {
                    break;
                }

                if (board[checkCoords.y()][checkCoords.x()] != PieceTypes.EMPTY.getValue()) {
                    if (checkIfCorrectLongKingCapture(board, new Move(coords.x(), coords.y(), landing.x(), landing.y()))) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    private boolean isRegularCaptureAvailable(BoardState boardState, Coordinates coords) {
        return POSSIBLE_DIRECTIONS.stream()
                .anyMatch(dir -> {
                    var captureCoords = new Coordinates(coords.x() + dir[0], coords.y() + dir[1]);
                    var landingCoords = new Coordinates(captureCoords.x() + dir[0], captureCoords.y() + dir[1]);
                    return isValidCapture(boardState, captureCoords, landingCoords);
                });
    }

    private boolean isValidCapture(BoardState boardState, Coordinates captureCoords, Coordinates landingCoords) {
        if (!isCoordinateWithinBoard(captureCoords) || !isCoordinateWithinBoard(landingCoords)) {
            return false;
        }

        PieceTypes movingPiece = boardState.getCurrentPlayer();
        PieceTypes capturePiece = PieceTypes.valueOfFigure(boardState.getBoardArray()[captureCoords.y()][captureCoords.x()]);

        return isMiddlePieceOpponentsAndLandingSquareEmpty(boardState.getBoardArray(), landingCoords, movingPiece, capturePiece);
    }

    private List<List<Move>> findLongestSequences(List<List<Move>> currentSequences, List<Move> newSequence) {
        if (currentSequences.isEmpty()) {
            return List.of(newSequence);
        }

        int currentLength = currentSequences.getFirst().size();
        int newLength = newSequence.size();

        if (newLength > currentLength) {
            return List.of(newSequence);
        } else if (newLength == currentLength) {
            List<List<Move>> result = new ArrayList<>(currentSequences);
            result.add(newSequence);
            return result;
        }
        return currentSequences;
    }
}

================
File: java/com/jereczek/checkers/game/model/board/BoardMapper.java
================
package com.jereczek.checkers.game.model.board;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.model.BoardEntity;
import com.jereczek.checkers.piece.PiecesNotationMapper;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;

public class BoardMapper {
    public static BoardState entityToBoardStateMapper(BoardEntity entity) {
        BoardState boardState = BoardState.builder()
                .boardArray(new int[BOARD_DIMENSION][BOARD_DIMENSION])
                .blackPieces(new HashMap<>())
                .whitePieces(new HashMap<>())
                .currentPlayer(entity.getCurrentPlayer())
                .build();
        populateBoardStateFromEntity(boardState, entity.getBlackPieces(), PieceTypes.BLACK);
        populateBoardStateFromEntity(boardState, entity.getWhitePieces(), PieceTypes.WHITE);
        populateBoardStateFromEntity(boardState, entity.getBlackKings(), PieceTypes.BLACK_KING);
        populateBoardStateFromEntity(boardState, entity.getWhiteKings(), PieceTypes.WHITE_KING);

        return boardState;
    }

    public static BoardEntity updateEntityFromBoardState(BoardEntity entity, BoardState boardState) {
        String[] whites = PiecesNotationMapper.convertPiecesToString(boardState.getWhitePieces());
        entity.setWhitePieces(whites[0]);
        entity.setWhiteKings(whites[1]);
        String[] blacks = PiecesNotationMapper.convertPiecesToString(boardState.getBlackPieces());
        entity.setBlackPieces(blacks[0]);
        entity.setBlackKings(blacks[1]);
        entity.setCurrentPlayer(boardState.getCurrentPlayer());

        entity.setBoard(map2dArrayToString(boardState.getBoardArray()));
        return entity;
    }

    private static void populateBoardStateFromEntity(BoardState boardState, String piecesList, PieceTypes type) {
        if (piecesList.isEmpty()) {
            return;
        }
        Map<Integer, PieceTypes> map;
        switch (type) {
            case WHITE, WHITE_KING -> map = boardState.getWhitePieces();
            case BLACK, BLACK_KING -> map = boardState.getBlackPieces();
            default -> throw new IllegalStateException("Unexpected value: " + type);
        }
        int[][] boardArray = boardState.getBoardArray();
        String[] pieceNotations = piecesList.split(";");
        for (String pieceNotation : pieceNotations) {
            String[] parts = pieceNotation.split("-");
            int x = Integer.parseInt(parts[0]);
            int y = Integer.parseInt(parts[1]);
            boardArray[y][x] = type.getValue();
            map.put(Coordinates.coordinatesToSquareNumber(x, y), type);
        }
        boardState.setBoardArray(boardArray);
        switch (type) {
            case WHITE, WHITE_KING -> boardState.setWhitePieces(map);
            case BLACK, BLACK_KING -> boardState.setBlackPieces(map);
            default -> throw new IllegalStateException("Unexpected value: " + type);
        }
    }

    public static String map2dArrayToString(int[][] boardArray) {
        return "[" + Arrays.stream(boardArray)
                .map(row -> "[" + Arrays.stream(row)
                        .mapToObj(Integer::toString)
                        .collect(Collectors.joining(",")) + "]")
                .collect(Collectors.joining(",")) + "]";
    }

}

================
File: java/com/jereczek/checkers/game/model/board/BoardState.java
================
package com.jereczek.checkers.game.model.board;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.Move;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.jereczek.checkers.enums.PieceTypes.*;
import static com.jereczek.checkers.game.model.board.Coordinates.coordinatesToSquareNumber;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.*;

@Data
@Builder
@AllArgsConstructor
public class BoardState {
    private Map<Integer, PieceTypes> whitePieces;

    private Map<Integer, PieceTypes> blackPieces;

    private int[][] boardArray;

    private PieceTypes currentPlayer;

    public BoardState() {
        this.whitePieces = startingWhitePieces;
        this.blackPieces = startingBlackPieces;
        this.boardArray = startingBoardState;
        this.currentPlayer = PieceTypes.WHITE;
    }

    public BoardState(BoardState other) {
        this.whitePieces = new HashMap<>(other.whitePieces);
        this.blackPieces = new HashMap<>(other.blackPieces);
        this.boardArray = Arrays.stream(other.boardArray).map(int[]::clone).toArray(int[][]::new);
        this.currentPlayer = other.currentPlayer;
    }

    public void movePiece(Move move, PieceTypes movingPieceType) {
        boardArray[move.startY()][move.startX()] = 0;
        boardArray[move.endY()][move.endX()] = movingPieceType.getValue();

        if (movingPieceType.equals(BLACK) || movingPieceType.equals(BLACK_KING)) {
            this.getBlackPieces().remove(coordinatesToSquareNumber(move.startX(), move.startY()));
            this.getBlackPieces().put(coordinatesToSquareNumber(move.endX(), move.endY()), movingPieceType);
        }
        if (movingPieceType.equals(WHITE) || movingPieceType.equals(WHITE_KING)) {
            this.getWhitePieces().remove(coordinatesToSquareNumber(move.startX(), move.startY()));
            this.getWhitePieces().put(coordinatesToSquareNumber(move.endX(), move.endY()), movingPieceType);
        }
    }

    public void cleanupCaptured(List<Coordinates> capturedPieces) {
        whitePieces.values().removeIf(PieceTypes.CAPTURED::equals);
        blackPieces.values().removeIf(PieceTypes.CAPTURED::equals);
        for (Coordinates capturedPiece : capturedPieces) {
            boardArray[capturedPiece.y()][capturedPiece.x()] = EMPTY.getValue();
        }
    }

    public  Map<Integer, PieceTypes> getCurrentPlayerPieces() {
        return getPiecesForPlayer(currentPlayer);
    }

    public Map<Integer, PieceTypes> getPiecesForPlayer(PieceTypes player) {
        return (player == WHITE || player == WHITE_KING) ?
                this.getWhitePieces() : this.getBlackPieces();
    }

    public void markCaptured(Coordinates coordinates) {
            int squareNumber = coordinatesToSquareNumber(coordinates.x(), coordinates.y());
            getWhitePieces().replace(squareNumber, CAPTURED);
            getBlackPieces().replace(squareNumber, CAPTURED);
    }
}

================
File: java/com/jereczek/checkers/game/model/board/BoardUtils.java
================
package com.jereczek.checkers.game.model.board;

import com.jereczek.checkers.enums.PieceTypes;

import static com.jereczek.checkers.enums.PieceTypes.*;
import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;

public class BoardUtils {
    public static boolean isCoordinateWithinBoard(Coordinates coordinates) {
        return coordinates.x() >= 0 && coordinates.x() < BOARD_DIMENSION && coordinates.y() >= 0 && coordinates.y() < BOARD_DIMENSION;
    }

    public static boolean isSquareEmptyAndWithinBoard(Coordinates coordinates, int[][] boardArray) {
        return isCoordinateWithinBoard(coordinates) && isSquareEmpty(coordinates, boardArray);
    }

    public static boolean isSquareEmpty(Coordinates coordinates, int[][] boardArray) {
        return boardArray[coordinates.y()][coordinates.x()] == PieceTypes.EMPTY.getValue();
    }

    public static boolean isMiddlePieceOpponentsAndLandingSquareEmpty(int[][] boardArray, Coordinates landingCoords, PieceTypes movingPiece, PieceTypes capturePiece) {
        return isOppositePiece(movingPiece, capturePiece)
                && BoardUtils.isSquareEmpty(landingCoords, boardArray);
    }

    public static boolean isOppositePiece(PieceTypes allyPiece, PieceTypes checkedPiece) {
        return switch (allyPiece) {
            case WHITE, WHITE_KING -> checkedPiece == BLACK || checkedPiece == BLACK_KING;
            case BLACK, BLACK_KING -> checkedPiece == WHITE || checkedPiece == WHITE_KING;
            default -> false;
        };
    }
}

================
File: java/com/jereczek/checkers/game/model/board/constants/BoardConstants.java
================
package com.jereczek.checkers.game.model.board.constants;

import com.jereczek.checkers.enums.PieceTypes;

import java.util.HashMap;
import java.util.List;

import static com.jereczek.checkers.enums.PieceTypes.BLACK;
import static com.jereczek.checkers.enums.PieceTypes.WHITE;

public class BoardConstants {
    public static final int BOARD_DIMENSION = 10;

    public static final HashMap<Integer, PieceTypes> startingWhitePieces = initWhiteMap();

    public static final HashMap<Integer, PieceTypes> startingBlackPieces = initBlackMap();

    public static final int[][] startingBoardState = initStartingBoardState();

    public static final List<int[]> POSSIBLE_DIRECTIONS = List.of(
            new int[]{-1, -1},
            new int[]{-1, 1},
            new int[]{1, -1},
            new int[]{1, 1}
    );

    private static int[][] initStartingBoardState() {
        int[][] board = new int[BOARD_DIMENSION][BOARD_DIMENSION];
        for (int i = 0; i < BoardConstants.BOARD_DIMENSION; i++) {
            for (int j = 0; j < 4; j++) {
                if ((i + j) % 2 == 1) {
                    board[j][i] = BLACK.getValue();
                }
            }
        }
        for (int i = 0; i < BoardConstants.BOARD_DIMENSION; i++) {
            for (int j = 6; j < BoardConstants.BOARD_DIMENSION; j++) {
                if ((i + j) % 2 == 1) {
                    board[j][i] = WHITE.getValue();
                }
            }
        }
        return board;
    }

    private static HashMap<Integer, PieceTypes> initWhiteMap() {
        HashMap<Integer, PieceTypes> map = new HashMap<>();
        for (int i = 31; i <= 50; i++) {
            map.put(i, WHITE);
        }
        return map;
    }

    private static HashMap<Integer, PieceTypes> initBlackMap() {
        HashMap<Integer, PieceTypes> map = new HashMap<>();
        for (int i = 1; i <= 20; i++) {
            map.put(i, BLACK);
        }
        return map;
    }
}

================
File: java/com/jereczek/checkers/game/model/board/Coordinates.java
================
package com.jereczek.checkers.game.model.board;

import static com.jereczek.checkers.game.model.board.constants.BoardConstants.BOARD_DIMENSION;

public record Coordinates(Integer x, Integer y) {

    public static Coordinates fromSquareNumber(Integer squareNumber) {
        int y = (squareNumber - 1) / (BOARD_DIMENSION / 2);
        int x = ((squareNumber - 1) % (BOARD_DIMENSION / 2)) * 2 + (y % 2 ==0 ? 1: 0);

        return new Coordinates(x, y);
    }

    public static int coordinatesToSquareNumber(int x, int y) {
        if ((x + y) % 2 != 0) {
            return (y * BOARD_DIMENSION + x) / 2 + 1;
        } else {
            throw new RuntimeException("Coordinates not valid");
        }
    }
}

================
File: java/com/jereczek/checkers/game/Move.java
================
package com.jereczek.checkers.game;

import com.jereczek.checkers.controller.dto.GamePlayDTO;
import com.jereczek.checkers.controller.dto.MoveDTO;
import com.jereczek.checkers.game.model.board.Coordinates;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public record Move(int startX, int startY, int endX, int endY) {

    public static List<Move> fromGameplayDto(GamePlayDTO gamePlayDTO) {
        List<Move> moves = new ArrayList<>();
        for (MoveDTO moveDTO : gamePlayDTO.getMoves()) {
            Coordinates startCords = Coordinates.fromSquareNumber(moveDTO.getStartPos());
            Coordinates endCords = Coordinates.fromSquareNumber(moveDTO.getEndPos());
            Move move = new Move(startCords.x(), startCords.y(), endCords.x(), endCords.y());
            moves.add(move);
        }
        return moves;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Move move)) return false;
        return startX == move.startX && startY == move.startY && endX == move.endX && endY == move.endY;
    }

    @Override
    public int hashCode() {
        return Objects.hash(startX, startY, endX, endY);
    }
}

================
File: java/com/jereczek/checkers/model/BoardEntity.java
================
package com.jereczek.checkers.model;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.jereczek.checkers.enums.PieceTypes;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "board_state")
public class BoardEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @JsonIgnoreProperties
    private int id;

    @Column(name = "board")
    private String board;

    @Column(name = "moves")
    private String moveList;

    @Column(name = "white_pieces")
    private String whitePieces;

    @Column(name = "black_pieces")
    private String blackPieces;

    @Column(name = "white_kings")
    private String whiteKings;

    @Column(name = "black_kings")
    private String blackKings;

    @Column(name = "current_player")
    private PieceTypes currentPlayer;
}

================
File: java/com/jereczek/checkers/model/GameData.java
================
package com.jereczek.checkers.model;

import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.movehelper.TipModel;
import jakarta.annotation.Nullable;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@Entity
@AllArgsConstructor
public class GameData {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Nullable
    @Convert(converter = MovesListConverter.class)
    private List<List<Move>> possibleMoves;

    @Nullable
    private Integer evaluation;
    @Embedded
    private TipModel tips;

    public GameData(){
        this.possibleMoves = new ArrayList<>();
        this.evaluation = 0;
        this.tips = new TipModel();
    }
}

================
File: java/com/jereczek/checkers/model/GameEntity.java
================
package com.jereczek.checkers.model;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.jereczek.checkers.enums.GameStatus;
import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.model.players.PlayerHuman;
import jakarta.annotation.Nullable;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@Entity
@Table(name = "game")
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class GameEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String gameID;

    private GameStatus gameStatus;

    @ManyToOne
    @JoinColumn(name = "player_one", nullable = false)
    private PlayerHuman player1;

    @ManyToOne
    @JoinColumn(name = "player_two")
    private PlayerHuman player2;

    @OneToOne
    @JoinColumn(name = "board")
    @JsonIgnoreProperties(value = "id")
    private BoardEntity boardStateEntity;

    @JsonAlias("pvp")
    private boolean isPvpGame;

    @Nullable
    private PieceTypes winner;

    @Nullable
    private Integer difficulty;

    @OneToOne
    private GameData gameData;

    @Column(name = "start_time")
    private Timestamp startTime;
}

================
File: java/com/jereczek/checkers/model/MovesListConverter.java
================
package com.jereczek.checkers.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.reflect.TypeToken;
import com.jereczek.checkers.game.Move;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

import java.lang.reflect.Type;
import java.util.List;

@Converter
public class MovesListConverter implements AttributeConverter<List<List<Move>>, String> {
    private final Gson gson = new Gson();
    private final Type listType = new TypeToken<List<List<Move>>>(){}.getType();

    @Override
    public String convertToDatabaseColumn(List<List<Move>> lists) {
        return gson.toJson(lists);
    }

    @Override
    public List<List<Move>> convertToEntityAttribute(String string) {
        JsonArray jsonObject = gson.fromJson(string, JsonArray.class);

        return gson.fromJson(jsonObject, listType);
    }
}

================
File: java/com/jereczek/checkers/model/players/Player.java
================
package com.jereczek.checkers.model.players;

import com.jereczek.checkers.enums.PlayerTypes;

/***
 * Interface adding layer of abstraction for Players
 */
public interface Player {
    PlayerTypes getPlayerType();
}

================
File: java/com/jereczek/checkers/model/players/PlayerCPU.java
================
package com.jereczek.checkers.model.players;

import com.jereczek.checkers.enums.PlayerTypes;

import java.util.UUID;

public class PlayerCPU implements Player {

    public static final UUID CPU_DEFAULT_UUID = UUID.fromString("11111111-1111-1111-1111-111111111111");

    private final PlayerTypes playerType = PlayerTypes.CPU;

    @Override
    public PlayerTypes getPlayerType() {
        return playerType;
    }
}

================
File: java/com/jereczek/checkers/model/players/PlayerHuman.java
================
package com.jereczek.checkers.model.players;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.jereczek.checkers.enums.PlayerTypes;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Entity
@Table(name = "player")
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class PlayerHuman implements Player {
    @Transient
    private final PlayerTypes playerType = PlayerTypes.HUMAN;

    @Id
    @Column(name = "id_player")
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID playerID;

    @Column(unique = true)
    private String username;
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private String password;

    @Override
    public PlayerTypes getPlayerType() {
        return playerType;
    }
}

================
File: java/com/jereczek/checkers/movehelper/TipGenerator.java
================
package com.jereczek.checkers.movehelper;

import com.jereczek.checkers.controller.dto.MoveDTO;
import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.CheckersGameLogic;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.ai.MiniMax;
import com.jereczek.checkers.game.ai.cache.BoardStateCacheService;
import com.jereczek.checkers.game.model.board.BoardState;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class TipGenerator {
    public static final int TIP_DEPTH_HANDICAP = 2;

    private final CheckersGameLogic checkersGameLogic;

    private final MiniMax miniMax;

    private final BoardStateCacheService boardStateCacheService;

    public TipGenerator(CheckersGameLogic checkersGameLogic, MiniMax miniMax, BoardStateCacheService boardStateCacheService) {
        this.checkersGameLogic = checkersGameLogic;
        this.miniMax = miniMax;
        this.boardStateCacheService = boardStateCacheService;
    }

    public TipModel generateTips(int difficulty, BoardState boardState, PieceTypes player) {
        TipModel tips = new TipModel();
        List<Move> bestMoves = generateBestMoves(difficulty + TIP_DEPTH_HANDICAP, boardState, player);
        if (!bestMoves.isEmpty()) {
            tips.setBestMove(convertMoveListToDto(bestMoves));
            BoardState boardStateAfterMove = checkersGameLogic.doMovements(bestMoves, boardState, false);
            tips.setEnemyRisk(convertMoveListToDto(generateBestMoves(difficulty, boardState, boardStateAfterMove.getCurrentPlayer())));
        }
        return tips;
    }

    private List<Move> generateBestMoves(int depth, BoardState boardState, PieceTypes player) {
        if (checkersGameLogic.checkWinner(boardState).isPresent()) {
            return Collections.emptyList();
        }

        List<List<Move>> availableMoves = boardStateCacheService.getAndInsertCache(boardState)
                .getPossibleMoves(boardState.getCurrentPlayer());

        if (availableMoves.size() == 1) {
            return availableMoves.getFirst();
        }
        return miniMax.miniMax(boardState, depth, player).getBestMoveSequence();
    }

    private List<MoveDTO> convertMoveListToDto(List<Move> moves) {
        return moves.stream()
                .map(MoveDTO::new)
                .collect(Collectors.toList());
    }
}

================
File: java/com/jereczek/checkers/movehelper/TipModel.java
================
package com.jereczek.checkers.movehelper;

import com.jereczek.checkers.controller.dto.MoveDTO;
import jakarta.persistence.Convert;
import jakarta.persistence.Embeddable;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;
@Data
@Embeddable
public class TipModel {
    @Convert(converter = TipsAttributeConverter.class)
    private List<MoveDTO> bestMove;
    @Convert(converter = TipsAttributeConverter.class)
    private List<MoveDTO> enemyRisk;

    public TipModel() {
        this.bestMove = new ArrayList<>();
        this.enemyRisk = new ArrayList<>();
    }
}

================
File: java/com/jereczek/checkers/movehelper/TipsAttributeConverter.java
================
package com.jereczek.checkers.movehelper;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.jereczek.checkers.controller.dto.MoveDTO;
import jakarta.persistence.AttributeConverter;

import java.lang.reflect.Type;
import java.util.List;

public class TipsAttributeConverter implements AttributeConverter<List<MoveDTO>, String> {
    private final Gson gson = new Gson();
    @Override
    public String convertToDatabaseColumn(List<MoveDTO> moveDTOS) {
        return gson.toJson(moveDTOS);
    }

    @Override
    public List<MoveDTO> convertToEntityAttribute(String string) {
        Type listType = new TypeToken<List<MoveDTO>>() {}.getType();
        return gson.fromJson(string, listType);
    }
}

================
File: java/com/jereczek/checkers/piece/Piece.java
================
package com.jereczek.checkers.piece;

import com.jereczek.checkers.enums.PieceTypes;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Builder
@AllArgsConstructor
public class Piece {
    private int positionX;
    private int positionY;
    private PieceTypes type;
}

================
File: java/com/jereczek/checkers/piece/PiecesNotationMapper.java
================
package com.jereczek.checkers.piece;

import com.jereczek.checkers.enums.PieceTypes;
import com.jereczek.checkers.game.model.board.Coordinates;

import java.util.HashMap;
import java.util.Map;

public class PiecesNotationMapper {
    public static HashMap<Integer, Piece> convertStringToPieces(String notation) {
        HashMap<Integer, Piece> pieces = new HashMap<>();
        String[] pieceNotations = notation.split(";");

        for (String pieceNotation : pieceNotations) {
            String[] parts = pieceNotation.split("-");
            int type = Integer.parseInt(parts[0]);
            int y = Integer.parseInt(parts[1]);
            int x = Integer.parseInt(parts[2]);

            Piece piece = new Piece(x, y, PieceTypes.valueOfFigure(type));
            pieces.put(Coordinates.coordinatesToSquareNumber(x, y), piece);
        }
        return pieces;
    }

    public static String[] convertPiecesToString(Map<Integer, PieceTypes> pieces) {
        StringBuilder regular = new StringBuilder();
        StringBuilder kings = new StringBuilder();
        pieces.forEach((square, type) -> {
            Coordinates coords = Coordinates.fromSquareNumber(square);
            switch (type) {
                case WHITE, BLACK -> {
                    regular.append(coords.x());
                    regular.append("-");
                    regular.append(coords.y());
                    regular.append(";");
                }
                case WHITE_KING, BLACK_KING -> {
                    kings.append(coords.x());
                    kings.append("-");
                    kings.append(coords.y());
                    kings.append(";");
                }
            }
        });

        return new String[]{regular.toString(), kings.toString()};
    }

}

================
File: java/com/jereczek/checkers/repositories/IBoardStateRepo.java
================
package com.jereczek.checkers.repositories;

import com.jereczek.checkers.model.BoardEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface IBoardStateRepo extends JpaRepository<BoardEntity, Integer> {
}

================
File: java/com/jereczek/checkers/repositories/IGameDataRepo.java
================
package com.jereczek.checkers.repositories;

import com.jereczek.checkers.model.GameData;
import org.springframework.data.jpa.repository.JpaRepository;

public interface IGameDataRepo extends JpaRepository<GameData, Integer> {

}

================
File: java/com/jereczek/checkers/repositories/IGameRepo.java
================
package com.jereczek.checkers.repositories;

import com.jereczek.checkers.enums.GameStatus;
import com.jereczek.checkers.model.GameEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.sql.Timestamp;
import java.util.UUID;

public interface IGameRepo extends JpaRepository<GameEntity, String> {
    @Query("SELECT g FROM GameEntity g WHERE g.player1.playerID != :uuid" +
            " AND g.player2 IS NULL" +
            " AND g.gameStatus = :gameStatus" +
            " AND g.startTime >= :olderThan " +
            " ORDER BY g.startTime ASC LIMIT 1")
    GameEntity findOldestForRandomConnectionNotOlderThan3Minutes(GameStatus gameStatus, UUID uuid, Timestamp olderThan);

    @Query("SELECT g FROM GameEntity g WHERE g.player1.playerID = :playerId OR g.player2.playerID = :playerId ORDER BY g.startTime DESC")
    Page<GameEntity> findGamesByPlayer(@Param("playerId") UUID playerId, Pageable pageable);
}

================
File: java/com/jereczek/checkers/repositories/IPlayerRepo.java
================
package com.jereczek.checkers.repositories;

import com.jereczek.checkers.model.players.PlayerHuman;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;
@Repository
public interface IPlayerRepo extends JpaRepository<PlayerHuman, UUID> {
    PlayerHuman findByUsername(String username);
}

================
File: java/com/jereczek/checkers/security/config/PasswordEncoderConfig.java
================
package com.jereczek.checkers.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordEncoderConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

================
File: java/com/jereczek/checkers/security/config/WebSecurityConfig.java
================
package com.jereczek.checkers.security.config;


import com.jereczek.checkers.security.PlayerAuthenticationSuccessHandler;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import java.util.List;

@Configuration
@RequiredArgsConstructor
@EnableWebSecurity
public class WebSecurityConfig {
    private final UserDetailsService userDetailsService;
    private final PlayerAuthenticationSuccessHandler authenticationSuccessHandler;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity, HandlerMappingIntrospector introspector) throws Exception {
        MvcRequestMatcher.Builder mvcMatcherBuilder = new MvcRequestMatcher.Builder(introspector);

        httpSecurity.csrf(csrf -> csrf.ignoringRequestMatchers(PathRequest.toH2Console())
                        .disable())
                .headers(headers -> headers
                        .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin))
                .cors(httpSecurityCorsConfigurer -> httpSecurityCorsConfigurer.configurationSource(corsConfigurationSource()))
                .authorizeHttpRequests(authorizeRequests -> authorizeRequests
                        .requestMatchers(mvcMatcherBuilder.pattern("/register")).permitAll()
                        .requestMatchers(PathRequest.toH2Console()).permitAll()
                        .anyRequest().permitAll())
                .formLogin(formLogin -> formLogin
                        .loginProcessingUrl("/login")
                        .successHandler(authenticationSuccessHandler)
                        .permitAll())
                .logout(logout -> logout
                        .logoutSuccessHandler((request, response, authentication) -> response.setStatus(HttpServletResponse.SC_OK))
                        .deleteCookies("JSESSIONID")
                        .invalidateHttpSession(true))
                .userDetailsService(userDetailsService);
        return httpSecurity.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowedOrigins(List.of("http://localhost:4200"));
        corsConfiguration.setAllowedMethods(List.of("GET", "POST"));
        corsConfiguration.setAllowCredentials(true);
        corsConfiguration.setAllowedHeaders(List.of("*"));
        corsConfiguration.setMaxAge(3600L);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);
        return source;
    }
}

================
File: java/com/jereczek/checkers/security/PlayerAuthenticationSuccessHandler.java
================
package com.jereczek.checkers.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jereczek.checkers.model.players.PlayerHuman;
import com.jereczek.checkers.repositories.IPlayerRepo;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
@RequiredArgsConstructor
@Component
public class PlayerAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    private final IPlayerRepo playerRepo;
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {
        User user = (User) authentication.getPrincipal();
        PlayerHuman player = playerRepo.findByUsername(user.getUsername());
        response.getWriter().write(new ObjectMapper().writeValueAsString(player));
    }
}

================
File: java/com/jereczek/checkers/security/UserDetailsServiceImpl.java
================
package com.jereczek.checkers.security;

import com.jereczek.checkers.model.players.PlayerHuman;
import com.jereczek.checkers.service.PlayerService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Optional;
@Service
@Transactional
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    private final PlayerService playerService;
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<PlayerHuman> playerHuman = Optional.ofNullable(playerService.findPlayerByUsername(username));
            if (playerHuman.isPresent()) {
                return new User(playerHuman.get().getUsername(), playerHuman.get().getPassword(), new ArrayList<>());
            } else {
                throw new UsernameNotFoundException("Player not found with username: " + username);
            }
    }
}

================
File: java/com/jereczek/checkers/service/CpuMovesAsyncConfig.java
================
package com.jereczek.checkers.service;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Configuration
public class CpuMovesAsyncConfig {

    @Bean
    public ExecutorService cpuMovesAsyncExecutorService() {
        return Executors.newCachedThreadPool();
    }
}

================
File: java/com/jereczek/checkers/service/GameService.java
================
package com.jereczek.checkers.service;

import com.jereczek.checkers.controller.dto.GamePlayDTO;
import com.jereczek.checkers.controller.dto.GameStartDTO;
import com.jereczek.checkers.controller.dto.PlayerDTO;
import com.jereczek.checkers.enums.GameStatus;
import com.jereczek.checkers.exception.connection.AllPlayersConnectedException;
import com.jereczek.checkers.exception.connection.GameConnectionError;
import com.jereczek.checkers.exception.connection.GameFinishedException;
import com.jereczek.checkers.exception.connection.GameNotFoundException;
import com.jereczek.checkers.game.CheckersGameLogic;
import com.jereczek.checkers.game.GameStateUtils;
import com.jereczek.checkers.game.Move;
import com.jereczek.checkers.game.ai.MiniMax;
import com.jereczek.checkers.game.ai.MiniMaxNode;
import com.jereczek.checkers.game.ai.evaluation.BoardEvaluator;
import com.jereczek.checkers.game.ai.movegenerator.MoveGenerator;
import com.jereczek.checkers.game.model.board.BoardMapper;
import com.jereczek.checkers.game.model.board.BoardState;
import com.jereczek.checkers.model.BoardEntity;
import com.jereczek.checkers.model.GameData;
import com.jereczek.checkers.model.GameEntity;
import com.jereczek.checkers.model.players.PlayerHuman;
import com.jereczek.checkers.movehelper.TipGenerator;
import com.jereczek.checkers.movehelper.TipModel;
import com.jereczek.checkers.repositories.IBoardStateRepo;
import com.jereczek.checkers.repositories.IGameDataRepo;
import com.jereczek.checkers.repositories.IGameRepo;
import com.jereczek.checkers.repositories.IPlayerRepo;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static com.jereczek.checkers.enums.PieceTypes.WHITE;
import static com.jereczek.checkers.model.players.PlayerCPU.CPU_DEFAULT_UUID;

@Slf4j
@Service
@Transactional
public class GameService {
    private final IGameRepo gameRepo;

    private final IPlayerRepo playerRepo;

    private final IBoardStateRepo boardStateRepo;

    private final IGameDataRepo gameDataRepo;

    private final CheckersGameLogic checkersGameLogic;

    private final MoveGenerator moveGenerator;

    private final TipGenerator tipGenerator;

    private final MiniMax miniMax;

    public GameService(IGameRepo gameRepo, IPlayerRepo playerRepo, IBoardStateRepo boardStateRepo, IGameDataRepo gameDataRepo, CheckersGameLogic checkersGameLogic, MoveGenerator moveGenerator, TipGenerator tipGenerator, MiniMax miniMax) {
        this.gameRepo = gameRepo;
        this.playerRepo = playerRepo;
        this.boardStateRepo = boardStateRepo;
        this.gameDataRepo = gameDataRepo;
        this.checkersGameLogic = checkersGameLogic;
        this.moveGenerator = moveGenerator;
        this.miniMax = miniMax;
        this.tipGenerator = tipGenerator;
    }

    public GameEntity createGame(GameStartDTO startDTO) {
        PlayerHuman player = playerRepo.findById(UUID.fromString(startDTO.getPlayerID())).get();
        BoardEntity boardEntity = BoardMapper.updateEntityFromBoardState(new BoardEntity(), new BoardState());
        boardStateRepo.save(boardEntity);

        GameEntity game = GameEntity.builder()
                .boardStateEntity(boardEntity)
                .player1(player)
                .isPvpGame(startDTO.isPvp())
                .gameStatus(GameStatus.NEW)
                .gameData(gameDataRepo.save(new GameData()))
                .startTime(Timestamp.from(Instant.now()))
                .build();
        if (!startDTO.isPvp()) {
            game.setPlayer2(playerRepo.findById(CPU_DEFAULT_UUID).get());
            game.setGameStatus(GameStatus.IN_PROGRESS);
            game.setDifficulty(Optional.ofNullable(startDTO.getDifficulty()).orElse(5));
        }
        gameRepo.save(game);
        return game;
    }

    public GameEntity getGameState(String gameID) throws GameNotFoundException {
        return gameRepo
                .findById(gameID)
                .orElseThrow(() -> new GameNotFoundException(gameID));
    }

    public GameEntity connectToPvpGame(PlayerDTO player2, String gameID) throws GameConnectionError {
        if (!gameRepo.existsById(gameID)) {
            throw new GameNotFoundException(gameID);
        }
        GameEntity game = gameRepo.findById(gameID).get();
        if (game.getPlayer2() != null) {
            throw new AllPlayersConnectedException(gameID);
        }
        if (game.getGameStatus().equals(GameStatus.FINISHED)) {
            log.debug("Tried to connect to game: {}, but it's already finished!", game.getGameID());
            throw new GameFinishedException();
        }
        if (!game.isPvpGame()) {
            throw new GameConnectionError("Game is not a pvp game!");
        }
        PlayerHuman player = playerRepo.findById(UUID.fromString(player2.getPlayerID())).get();
        game.setPlayer2(player);
        game.setGameStatus(GameStatus.IN_PROGRESS);
        gameRepo.save(game);
        return game;
    }

    public GameEntity connectToRandomGame(PlayerDTO player2) {
        PlayerHuman player = playerRepo.findById(UUID.fromString(player2.getPlayerID())).get();

        GameEntity game = gameRepo.findOldestForRandomConnectionNotOlderThan3Minutes(GameStatus.NEW, UUID.fromString(player2.getPlayerID()),
                Timestamp.from(Instant.now().minus(3, ChronoUnit.MINUTES)));
        game.setPlayer2(player);
        game.setGameStatus(GameStatus.IN_PROGRESS);
        gameRepo.save(game);
        return game;
    }

    public GameEntity gamePlayPvp(GamePlayDTO gamePlayDTO) {
        GameEntity game = gameRepo.findById(gamePlayDTO.getGameID())
                .orElseThrow(() -> new GameNotFoundException(gamePlayDTO.getGameID()));
        BoardState originalBoardState = GameStateUtils.validateAndGetBoardState(game, gamePlayDTO);

        List<Move> moves = Move.fromGameplayDto(gamePlayDTO);
        BoardState boardState = processMove(originalBoardState, moves);
        game.setBoardStateEntity(BoardMapper.updateEntityFromBoardState(game.getBoardStateEntity(), boardState));
        updateAvailableMovesForPvp(boardState, game);
        checkersGameLogic.checkWinner(boardState).ifPresent(game::setWinner);
        gameRepo.save(game);

        return game;
    }

    public GameEntity gamePlayCpu(GameEntity game, int depth) {
        BoardState originalBoardState = BoardMapper.entityToBoardStateMapper(game.getBoardStateEntity());

        MiniMaxNode cpuMove = miniMax.miniMax(originalBoardState, depth, originalBoardState.getCurrentPlayer());

        var updatedBoardState = processMove(originalBoardState, cpuMove.getBestMoveSequence());
        checkersGameLogic.checkWinner(updatedBoardState).ifPresent(game::setWinner);
        game.setBoardStateEntity(BoardMapper.updateEntityFromBoardState(game.getBoardStateEntity(), updatedBoardState));
        GameData gameData = updateGameData(updatedBoardState, game);
        game.setGameData(gameData);
        gameRepo.save(game);

        return game;
    }

    public GameEntity generateAndUpdateTips(String gameId) {
        GameEntity game = gameRepo.findById(gameId).orElseThrow(() -> new GameNotFoundException(gameId));
        BoardState boardState = BoardMapper.entityToBoardStateMapper(game.getBoardStateEntity());

        TipModel tips = tipGenerator.generateTips(
                Optional.ofNullable(game.getDifficulty()).orElse(5),
                boardState, WHITE
        );

        GameData gameData = game.getGameData();
        gameData.setTips(tips);
        game.setGameData(gameData);
        gameRepo.save(game);
        return game;
    }

    private BoardState processMove(BoardState boardState, List<Move> moves) {
        return checkersGameLogic.doMovements(moves, boardState, true);
    }

    private GameData updateGameData(BoardState boardState, GameEntity game) {
        GameData gameData = Optional.ofNullable(game.getGameData()).get();
        Integer evaluation = new BoardEvaluator(boardState).evaluateBoard();
        gameData.setPossibleMoves(moveGenerator.generateMoves(boardState));
        gameData.setEvaluation(evaluation);
        return gameData;
    }

    private GameData updateAvailableMovesForPvp(BoardState boardState, GameEntity game) {
        GameData gameData = Optional.ofNullable(game.getGameData()).orElseGet(() -> {
            GameData newData = new GameData();
            return gameDataRepo.save(newData);
        });

        List<List<Move>> availableMoves = moveGenerator.generateMoves(boardState);
        gameData.setPossibleMoves(availableMoves);

        return gameDataRepo.save(gameData);
    }
}

================
File: java/com/jereczek/checkers/service/PlayerService.java
================
package com.jereczek.checkers.service;

import com.jereczek.checkers.model.players.PlayerHuman;
import com.jereczek.checkers.repositories.IPlayerRepo;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class PlayerService {
    private final IPlayerRepo playerRepo;
    private final PasswordEncoder passwordEncoder;

    public PlayerHuman registerNewPlayer(PlayerHuman playerHuman) {
        playerHuman.setPassword(passwordEncoder.encode(playerHuman.getPassword()));
        return playerRepo.save(playerHuman);
    }

    public PlayerHuman findPlayerByUsername(String username) {
        return playerRepo.findByUsername(username);
    }
}

================
File: resources/application-dev.yml
================
spring:
  datasource:
    username: sa
    password: password
    url: jdbc:h2:file:./demodb;AUTO_SERVER=TRUE
    driver-class-name: org.h2.Driver
  jpa:
    defer-datasource-initialization: true
    generate-ddl: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
    show-sql: false
  sql:
    init:
      schema-locations: classpath:schema-update.sql
      data-locations: classpath:data.sql
      mode: always
  h2:
    console:
      enabled: true
      settings:
        web-allow-others: true
logging:
  level:
    com.jereczek.checkers: debug

================
File: resources/application-prod.yml
================
spring:
  datasource:
    username: postgres
    password: 12345
    url: jdbc:postgresql://localhost:5432/checkers-simulator
  jpa:
    generate-ddl: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
    show-sql: false
logging:
  level:
    com.jereczek.checkers: trace
    org:
      springframework:
        security: DEBUG

================
File: resources/application.yml
================
spring:
  profiles:
    active: dev
server:
  servlet:
    session:
      timeout: 180m

================
File: resources/data.sql
================
MERGE INTO player (id_player, password, username) VALUES ('11111111-1111-1111-1111-111111111111', null, 'CPU');
MERGE INTO player (id_player, password, username) VALUES ('22222222-2222-2222-2222-222222222222', '$2a$10$1FA6IYDMCHGY7QbuZj0JGOSl5cP0LJAAGNMLdrTVCkgCoY6THdmHq', 'user1');

================
File: resources/schema-update.sql
================
alter table GAME_DATA
    alter column POSSIBLE_MOVES CHAR LARGE OBJECT;
